<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Klotski of Video</title>
        <style>
            body {
                margin:0;
                background: #363636;
                color: #afafaf;
                height: 100vh;
            }
        </style>
    </head>
    <body style="display: flex;align-items: center;flex-direction: column;">
        <div style="padding:20px 0 8px 0;height:160px;display: flex;flex-direction: column;align-items: center;justify-content: space-between;">
            <span style="font-size: 18px;font-weight: bold;">女神华容道</span>
            <span style="font-size: 12px;">by woody 不去便利店的少少</span>
            <span onclick="initRandom(100);" style="font-size: 12px;padding:3px 6px;border: 1px solid #fafafa;border-radius: 6px;box-shadow: 1px 2px 8px rgb(200 200 200 / 0.1);">打乱顺序</span>
            <div id="msg" style="height: 25px;font-size: 18px;font-weight: bold;"></div>
        </div>
    </body>
</html>
<script>
// 创建游戏板块的DOM元素
const boardElement = document.createElement('div');

const video = document.createElement("video");
video.muted = true;
video.autoplay = true;
video.src= window.innerHeight > window.innerWidth ? "./m.mp4" : "./b.mp4"
video.controls = true
video.style.position = 'absolute';
video.style.top = 0;
video.style.left = 0;
video.style.opacity = 0.1
video.loop = true

const boardSize = 3; // 游戏区格子数
const video_rows = boardSize,
      video_cols = boardSize      
const duration = 200; // 动画持续时间

let boardWidth , boardHeight,  // 总的宽度和高度
    blockWidth , blockHeight  // 每个方块的宽度和高度
let allowClick = true; // 是否允许点击

// 定义游戏板块的初始布局
// const initialLayout = [
//     [1, 2, 3],
//     [4, 5, 6],
//     [7, 8, 0] // 0代表空格
// ];
const initialLayout = [
    [1, 2, 3],
    [4, 0, 5],
    [7, 8, 6] // 0代表空格
];

// 创建方块的DOM元素
const createBlockElement = function () {
    var blockElement = document.createElement('div');
    blockElement.style.width = (blockWidth - 2) + 'px';
    blockElement.style.height = (blockHeight - 2) + 'px';
    blockElement.style.border = '1px solid #3e3e3e';
    blockElement.style.margin = '1px';
    blockElement.style.overflow = 'hidden';
    blockElement.style.display = 'flex';
    blockElement.style.justifyContent = 'center';
    blockElement.style.alignItems = 'center';
    blockElement.style.cursor = 'pointer';
    blockElement.style.position = "absolute";
    blockElement.style.transition = `top ${duration/1000}s linear 0s , left ${duration/1000}s linear 0s`;
    return blockElement;
};


// 移动方块的逻辑
const moveBlock = function () {
    if(!allowClick) return

    var blockElement = this;
    var row = parseInt(blockElement.dataset.row);
    var col = parseInt(blockElement.dataset.col);

    // 检查空格相邻的方块，如果有则交换位置
    if (row > 0 && initialLayout[row-1][col] === 0) {
        swapBlocks(row, col, row-1, col);
    } else if (row < boardSize-1 && initialLayout[row+1][col] === 0) {
        swapBlocks(row, col, row+1, col);
    } else if (col > 0 && initialLayout[row][col-1] === 0) {
        swapBlocks(row, col, row, col-1);
    } else if (col < boardSize-1 && initialLayout[row][col+1] === 0) {
        swapBlocks(row, col, row, col+1);
    }

    // 检查是否完成拼图
    if ( checkWin()) {
        document.getElementById('msg').innerHTML = "恭喜你，拼图成功！";
    }else{
        document.getElementById('msg').innerHTML = "";
    }
};

// 交换方块的位置
const swapBlocks = function (row1, col1, row2, col2) {
    var temp = initialLayout[row1][col1];
    initialLayout[row1][col1] = initialLayout[row2][col2];
    initialLayout[row2][col2] = temp;
    updateLayout(row1, col1, row2, col2);
};

// 更新方块的布局
const updateLayout = function (row1, col1, row2, col2) {
    allowClick = false
    // console.log(row1, col1, row2, col2,row1*boardSize+(col1+1)-1,row2*boardSize+(col2+1)-1)
    const blockElements = boardElement.querySelectorAll('div');
    const start = blockElements[row1*boardSize+(col1+1)-1]
    const end = blockElements[row2*boardSize+(col2+1)-1]
    
    const start_left = start.style.left,
          start_top = start.style.top
          start_dataset_row = start.dataset.row,
          start_dataset_col = start.dataset.col
    
    start.style.left = end.style.left
    start.style.top = end.style.top
    start.dataset.row = end.dataset.row
    start.dataset.col = end.dataset.col
    end.style.left = start_left
    end.style.top = start_top
    end.dataset.row = start_dataset_row
    end.dataset.col = start_dataset_col
   
    setTimeout(() => {
        swap(start,end)
        allowClick = true;
    },duration)

};

const swap = function (nodeA, nodeB) {
    const parentA = nodeA.parentNode;
    const siblingA = nodeA.nextSibling === nodeB ? nodeA : nodeA.nextSibling;

    // Move `nodeA` to before the `nodeB`
    nodeB.parentNode.insertBefore(nodeA, nodeB);

    // Move `nodeB` to before the sibling of `nodeA`
    parentA.insertBefore(nodeB, siblingA);
};


// 检查是否完成拼图
const checkWin = function () {
    var count = 1;
    for (var row = 0; row < boardSize; row++) {
        for (var col = 0; col < boardSize; col++) {
            let target = initialLayout[row][col] === 0 ? boardSize**2 : initialLayout[row][col] 
            if (count !== target) {
                return false;
            }
            count++;
        }
    }
    return true;
};

video.addEventListener('loadeddata', function () {
    console.log("video loaded")
    console.log(video.videoWidth, video.videoHeight)
    console.log("client",document.body.clientWidth,document.body.clientHeight)

    // boardWidth = document.body.clientWidth
    // boardHeight = boardWidth/video.videoWidth * video.videoHeight

    boardHeight = document.body.clientHeight*0.75
    boardWidth = boardHeight/video.videoHeight * video.videoWidth
    
    blockWidth = Math.floor(boardWidth / boardSize);   // 每个方块的宽度和高度
    blockHeight = Math.floor(boardHeight / boardSize); // 每个方块的宽度和高度

    video.width = boardWidth;
    video.height = boardHeight;

 
    boardElement.style.width = boardWidth + 'px';
    boardElement.style.height = boardHeight + 'px';
    boardElement.style.position = 'relative';

    const canvas = document.createElement("canvas");
    boardElement.appendChild(video)
    // 将游戏板块添加到页面中
    document.body.appendChild(boardElement);

    ctx = canvas.getContext('2d');
    canvas.width = video.width;
    canvas.height = video.height;

    const frames = initFrames(video_rows,video_cols)

    // 初始化游戏
    initGameLayout(frames);

    setInterval(() => {
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        updateFrames(canvas,frames,video_rows,video_cols)
    },1000/25)
    
});

function initFrames(rows,cols){
    const frames = []
 
    for (let i = 0; i < video_rows*video_cols; i++){
        const frame = document.createElement('canvas')
        frame.width = blockWidth
        frame.style.width = blockWidth + 'px'
        frame.height = blockHeight
        frame.style.height = blockHeight + 'px'
        frames.push(frame)
    }
    return frames
}

function updateFrames(canvas,frames, r, c) {
    let idx = 0
    for (let i = 0; i < r; i++) {
        for (let j = 0; j < c; j++) {
            const frame = frames[idx]
            const ctx = frame.getContext('2d')
            const frameWidth = frame.width
            const frameHeight = frame.height
            ctx.drawImage(canvas, j * frameWidth, i * frameHeight, frameWidth, frameHeight, 0, 0, frameWidth, frameHeight)
            idx++
        }
    }
}

// 初始化游戏布局
const initGameLayout = function (frames) {
    let num = 1
    let idx = 0 
    for (var row = 0; row < boardSize; row++) {
        for (var col = 0; col < boardSize; col++) {
            var number = initialLayout[row][col];
            var blockElement = createBlockElement();
            blockElement.style.top = (row * blockHeight) + 'px';
            blockElement.style.left = (col * blockWidth) + 'px';
            blockElement.dataset.row = row.toString();
            blockElement.dataset.col = col.toString();
            blockElement.dataset.val = number.toString();
            blockElement.addEventListener('click', moveBlock);
            if (number != 0) {
                blockElement.appendChild(frames[number-1])
            }
            boardElement.appendChild(blockElement);
            num++
        }
    }
};


//*******************************************************************


function initRandom(step){
    video.muted = false
    video.volume = 0.1
    const blockElements = boardElement.querySelectorAll('div');
    setTimeout(() => {
        const idx = Math.floor(Math.random() * blockElements.length);
        blockElements[idx].click()
        step--
        if(step > 0) initRandom(step)
    },0)
}

window.addEventListener("resize",() => {
    location.reload()
})
</script>